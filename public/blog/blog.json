{
  "posts": [

    {
      "id": "p3",
      "title": "ReactCSSTransitionGroup",
      "url": "reactcsstransitiongroup",
      "teaser": "How to utilize the ReactCSSTransitionGroup to transition between components in React",
      "date": "Jan 22, 2016",
      "content": [
        ["h3", "Transitions using CSS"],
        ["p", "Transitions in CSS are easy. Simply add a transition property to the appropriate selector, specify which property is to be changed, the duration of the transition, pace and an optional delay. An example of transitioning the color and size of h1 elements is shown below, where each transition will last a half second. "],
        ["img", "/public/blog/reactcsstransition/transition4.JPG"],
        ["p", "These CSS transitions work just fine in React and can be used all over your code to create a smoother and more dynamic-feeling user experience. One of the benefits of React is the way that pages re-render themselves on state changes, adding and removing the appropriate components. Using transitions for these changes would be much more challenging than a typical CSS transition, and would require some pretty complex code in the React lifecycle methods for each component to properly add and remove the appropriate classes at the correct time. Fortunately, there is an extremely helpful add-on called the ReactCSSTransitionGroup which does all the heavy lifting for us."],
        ["h3", "ReactCSSTransitionGroup"],
        ["p", "The way the ReactCSSTransitionGroup works is that is can be attached to any component or array of components, and trigger transitions or animations when these components enter the DOM, leave the DOM, or first appear on a page load. I’ve created a simple app example that features 2 main components, List and ListItem. The code is below for reference:"],
        ["img", "/public/blog/reactcsstransition/transition1.JPG"],
        ["img", "/public/blog/reactcsstransition/transition2.JPG"],
        ["img", "/public/blog/reactcsstransition/transition3.JPG"],
        ["p", "The functionality works, where clicking an item will remove it from the DOM, while entering new info into the inputs and clicking the submit button will add a new ListItem to the DOM. While the functionality is nice, the sudden changes are a bit too abrupt and would clearly be better with some simple transitions. Below is the current behavior:"],
        ["img", "/public/blog/reactcsstransition/transitiongif1.gif"],
        ["h3", "Installing from NPM"],
        ["p", "So how could we animate this with the ReactCSSTransitionGroup? Pretty easily, actually. The first step is to install the add-on using npm, with the command ‘npm i –save react-addons-css-transition-group’. Next we will require it in the appropriate component. Now, the component we are looking to animate is ListItem, however we do NOT want to use the ReactCSSTransitionGroup on that element. This is because the ReactCSSTransitionGroup must already be mounted on the DOM for it to trigger the enter animation, and must remain on the DOM after an element is removed to trigger the removal animation. For these reasons, we are going to require it in the List component, even though we are not animating the List."],
        ["img", "/public/blog/reactcsstransition/transition5.JPG"],
        ["p", "Once we have required the group, we treat it just like any other element and place it right inside of the return method in our component. Place the ReactCSSTransitionGroup (or whatever you want to save the name as when you first required it) surrounding the element/s that you wish to transition. Also be sure to have supplied a key to these elements, which are needed for the transitions to work. There are a few properties to specify inside of the element tag:"],
        ["ol", ["transitionName (this is what the class will be called in the CSS file)", "transitionEnterTimeout (the amount of time the enter transition – including any delay – should take)", "transitionLeaveTimeout (the amount of time the exit transition should last)", "Optional: transitionAppear and transitionAppearTimeout. These are for using a transition on the initial page load. transitionAppear is, by default, set to false, so to trigger an appear animation it must be set to {true} and the appear timeout should also be specified."]],
        ["p", "Make sure that the ‘key’ given to each element that can be transitioned is not only unique with the current state of like items, but would remain unique if compared to a future or past state of the items. In other words, do NOT use the index, since if an item with index of 2 is removed, on the next render there could still be an item with an index of 2. This would confuse the ReactCSSTransitionGroup addon, so an easy fix is to make the key something completely unique, as I have done here by using the name property of each object. In practice this still is not a perfect key since we could theoretically want multiple people with the same name in our list, but for simplicity it is unique enough for this example."],
        ["img", "/public/blog/reactcsstransition/transition6.JPG"],
        ["h3", "Adding ReactCSSTransitionGroup to React code"],
        ["p", "I have created the transitionEnterTimeout and transitionLeave timeout, and set them both to 500ms. I also named the transition ‘li-trans’."],
        ["img", "/public/blog/reactcsstransition/transition7.JPG"],
        ["p", "Now let’s look at the CSS:"],
        ["img", "/public/blog/reactcsstransition/transition8.JPG"],
        ["p", "The way this works is that the we are given a few classes based on the name of the transition. I named the transition ‘li-trans’ (you can name the transition whatever you like). For the enter transition, there are 2 classes to write:"],
        ["ol", ["*name of transition*-enter (this is how the new element will appear when it first enters the DOM)", "*name of transition*-enter-active (this is how the new element will appear at the end of the transition)"]],
        ["p", "What ReactCSSTransitionGroup does under the hood is add the ‘enter’ class to your new element the instant it enters the DOM, and on the next ‘tick’, the ‘enter-active’ class is added. Therefore we also need to add the transition property in the CSS, as the ReactCSSTransitionGroup is not really doing any transitioning at all, it is merely just adding classes at the appropriate time. The same holds true for leave animations:"],
        ["ol", ["*name of transition*-leave (How the element should appear as the leave transition begins)", "*name of transition*-leave-active (How the element should appear at the end of the transition)"]],
        ["p", "Now let’s see how these transitions look:"],
        ["img", "/public/blog/reactcsstransition/transitiongif2.gif"],
        ["p", "As we see here, when a new list item is first added to the DOM it uses the rotateY transition we gave it, which takes 500ms. When we remove an element it first completes the transition from scale(1) to scale(0). Easy!"],
        ["h3", "Animate on page load with transitionAppear"],
        ["p", "The transitionEnter animation triggers when a component enters the already-existing DOM, so to animate on page load we can use the transitionAppear property. The first step is to set transitionAppear to true, says by default it does not trigger. And as was with enter and leave, specify a duration for the animation."],
        ["img", "/public/blog/reactcsstransition/transition9.JPG"],
        ["p", "Here is the code for the CSS, along with the resulting affect when the page is refreshed/first loaded. The same rules apply as with the ‘enter’ animations, only the keyword this time is ‘appear’. In this example I also decided to use a CSS animation and not just a transition."],
        ["img", "/public/blog/reactcsstransition/transition10.JPG"],
        ["img", "/public/blog/reactcsstransition/transitiongif3.gif"]


      ]
    },



    {
      "id": "p2",
      "title": "Hoisting",
      "url": "hoisting",
      "teaser": "What 'hoisting' really means in JS",
      "date": "Jan 20, 2016",
      "content": [
        ["p", "Hoisting is a concept to help us humans understand how JavaScript runs code. However, it is NOT actually how the JavaScript engine works. The idea of hoisting is that variable and function declarations are ‘moved’ to the beginning of code at runtime. That would explain how JavaScript is able to run and evaluate the following code, even though the printStuff function is called before it is declared:"],
        ["img", "/public/blog/scope/example1.JPG"],
        ["p", "But while this works nicely for a function declaration, what about a variable declaration?"],
        ["img", "/public/blog/scope/example2.JPG"],
        ["p", "Here, undefined is printed. So hoisting must not have happened, right? Let’s consider another example:"],
        ["img", "/public/blog/scope/example3.JPG"],
        ["p", "With this code, the ‘banana’ variable is not undefined like the last example, it is undeclared. Undefined is NOT the same thing as undeclared, as undefined means that a variable does exist, it just has no value. Whereas undeclared means that the variable does not exist."],
        ["p", "So what is happening here? Is hoisting going on or not? Well, nothing in the code is being ‘moved’ anywhere else. What the JavaScript engine is really doing is running through the code multiple times. The first time is the compiling phase, where it is looking for any variable for function declarations. With a variable declaration, all that the engine cares about is the declaration, not the initialization. This is why, in example 2, we received ‘undefined’ as the value for banana. JavaScript was aware that we declared a banana variable, as evidenced by the fact that we did not get a reference error, however clearly the compiling phase did not check to see what we wanted to set banana equal to. When we ran console.log(banana), JavaScript did not know the value of banana because we haven’t set that yet in the code, and it does not look at it during the compiling phase."],
        ["p", "So how did the first example work with the printStuff function? Because we did not call for a function initialization by setting it equal to a variable like so:"],
        ["img", "/public/blog/scope/example4.JPG"],
        ["p", "Why didn’t this code work? Because here we tried to use an initialization again. Read the error message, JavaScript did not throw a reference error to PrintNow, meaning that it had already seen it in the compiling phase. However like the variable initialization in example 2, our variable here is coming back undefined again, which is why JavaScript is telling us that PrintNow is not a function."],
        ["p", "But a function declaration is different. Instead of both declaring a variable and then initializing a value like the past example, a function declaration is compiled in its entirety. This means that we can call for a function that is later declared and JavaScript will be able to run our code."],
        ["p", "The last thing to remember about hoisting: It’s not real! It’s simply a way that is supposed to simplify the way declarations work in JavaScript. Personally I think it would be easier to just teach what is actually going on – that there is a compilation phase followed by an execution phase, and that the JavaScript engine actually runs through our code multiple times."]


      ]
    },
    {
      "id": "p1",
      "title": "IIFEs and Modules",
      "url": "iife",
      "teaser": "What an IIFE is and how it can be useful",
      "date": "Jan 18, 2016",
      "content": [
        ["p", "IIFE stands for an immediately invoked function expression. It has a few benefits:"],
        ["ol", ["Creates a new scope for variables, which prevents poling the global scope.", "Is great for creating modules as it can contain both public and private methods", "Leads to cleaner code because it is executed immediately and does not have to be both defined and then later called."]],
        ["p", "The syntax for an iife is below:"],
        ["img", "/public/blog/iife/iife1.JPG"],
        ["p", "The extra parentheses at the end are what immidately invoke (hence the name) the function, without being explicitly called later. Those parentheses can be placed either directly after or before the closing parentheses that wraps the function. An iife can also take an argument:"],
        ["img", "/public/blog/iife/iife2.JPG"],
        ["p", "An iife is a great way to create a module in JavaScript since it can contain both public and private methods. It can also be saved to a variable. These features are all shown below:"],
        ["img", "/public/blog/iife/iife3.JPG"],
        ["p", "There are a number of cool things going on here. First, the backticks ( ` ) are a new ES6 feature that allow for string interpolation in JavaScript. But back to the IIFE, by saving it to the variable myModule it is no longer being invoked at runtime, but rather is accessible to us later in the program. When we call the sayEverything method on line 23, sayEverything is able to access both the sayAge and sayFood methods, which are both private and inaccessible directly from the global scope. On line 24 the takeArg method shows that we can pass in a parameter to one of these public methods. Line 25 shows that none of the function defined outside of the return are private, and not available from the global scope. To make a method public, simply define it inside of the return, and separate multiple functions with commas. These public methods have access to all private functions and variables defined inside of the IIFE."]

      ]
    }

  ]
}