{
  "posts": [

    {
      "title": "Closures",
      "content": [
        ["p", "first paragraph"],
        ["h2", "header"]
      ]
    },

    {
      "title": "Let",
      "content": [
        ["p", "another p"],
        ["h2", "another header"]
      ]
    },

    {
      "title": "Scope",
      "content": [
        ["h2", "Hoisting"],
        ["p", "Hoisting is concept to help us humans understand how JavaScript runs code. However, it is NOT actually how the JavaScript engine works. The idea of hoisting is that variable and function declarations are ‘moved’ to the beginning of code at runtime. That would explain how JavaScript is able to run and evaluate the following code, even though the printStuff function is called before it is declared:"],
        ["img", "/public/blog/scope/example1.JPG"],
        ["p", "But while this works nicely for a function declaration, what about a variable declaration?"],
        ["img", "/public/blog/scope/example2.JPG"],
        ["p", "Here, undefined is printed. So hoisting must not have happened, right? Let’s consider another example:"],
        ["img", "/public/blog/scope/example3.JPG"],
        ["p", "With this code, the ‘banana’ variable is not undefined like the last example, it is undeclared. Undefined is NOT the same thing as undeclared, as undefined means that a variable does exist, it just has no value. Whereas undeclared means that the variable does not exist."],
        ["p", "So what is happening here? Is hoisting going on or not? Well, nothing in the code is being ‘moved’ anywhere else. What the JavaScript engine is really doing is running through the code multiple times. The first time is the compiling phase, where it is looking for any variable for function declarations. With a variable declaration, all that the engine cares about is the declaration, not the initialization. This is why, in example 2, we received ‘undefined’ as the value for banana. JavaScript was aware that we declared a banana variable, as evidenced by the fact that we did not get a reference error, however clearly the compiling phase did not check to see what we wanted to set banana equal to. When we ran console.log(banana), JavaScript did not know the value of banana because we haven’t set that yet in the code, and it does not look at it during the compiling phase."],
        ["p", "So how did the first example work with the printStuff function? Because we did not call for a function initialization by setting it equal to a variable like so:"],
        ["img", "/public/blog/scope/example4.JPG"],
        ["p", "Why didn’t this code work? Because here we tried to use an initialization again. Read the error message, JavaScript did not throw a reference error to PrintNow, meaning that it had already seen it in the compiling phase. However like the variable initialization in example 2, our variable here is coming back undefined again, which is why JavaScript is telling us that PrintNow is not a function."],
        ["p", "But a function declaration is different. Instead of both declaring a variable and then initializing a value like the past example, a function declaration is compiled in its entirety. This means that we can call for a function that is later declared and JavaScript will be able to run our code."],
        ["p", "The last thing to remember about hoisting: It’s not real! It’s simply a way that is supposed to simplify the way declarations work in JavaScript. Personally I think it would be easier to just teach what is actually going on – that there is a compilation phase followed by an execution phase, and that the JavaScript engine actually runs through our code multiple times."]


      ]
    }

  ]
}