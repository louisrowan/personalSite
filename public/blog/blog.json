{
  "posts": [



    {
      "title": "Scope",
      "content": [
        ["h2", "Hoisting"],
        ["p", "Hoisting is concept to help us humans understand how JavaScript runs code. However, it is NOT actually how the JavaScript engine works. The idea of hoisting is that variable and function declarations are ‘moved’ to the beginning of code at runtime. That would explain how JavaScript is able to run and evaluate the following code, even though the printStuff function is called before it is declared:"],
        ["img", "/public/blog/scope/example1.JPG"],
        ["p", "But while this works nicely for a function declaration, what about a variable declaration?"],
        ["img", "/public/blog/scope/example2.JPG"],
        ["p", "Here, undefined is printed. So hoisting must not have happened, right? Let’s consider another example:"],
        ["img", "/public/blog/scope/example3.JPG"],
        ["p", "With this code, the ‘banana’ variable is not undefined like the last example, it is undeclared. Undefined is NOT the same thing as undeclared, as undefined means that a variable does exist, it just has no value. Whereas undeclared means that the variable does not exist."],
        ["p", "So what is happening here? Is hoisting going on or not? Well, nothing in the code is being ‘moved’ anywhere else. What the JavaScript engine is really doing is running through the code multiple times. The first time is the compiling phase, where it is looking for any variable for function declarations. With a variable declaration, all that the engine cares about is the declaration, not the initialization. This is why, in example 2, we received ‘undefined’ as the value for banana. JavaScript was aware that we declared a banana variable, as evidenced by the fact that we did not get a reference error, however clearly the compiling phase did not check to see what we wanted to set banana equal to. When we ran console.log(banana), JavaScript did not know the value of banana because we haven’t set that yet in the code, and it does not look at it during the compiling phase."],
        ["p", "So how did the first example work with the printStuff function? Because we did not call for a function initialization by setting it equal to a variable like so:"],
        ["img", "/public/blog/scope/example4.JPG"],
        ["p", "Why didn’t this code work? Because here we tried to use an initialization again. Read the error message, JavaScript did not throw a reference error to PrintNow, meaning that it had already seen it in the compiling phase. However like the variable initialization in example 2, our variable here is coming back undefined again, which is why JavaScript is telling us that PrintNow is not a function."],
        ["p", "But a function declaration is different. Instead of both declaring a variable and then initializing a value like the past example, a function declaration is compiled in its entirety. This means that we can call for a function that is later declared and JavaScript will be able to run our code."],
        ["p", "The last thing to remember about hoisting: It’s not real! It’s simply a way that is supposed to simplify the way declarations work in JavaScript. Personally I think it would be easier to just teach what is actually going on – that there is a compilation phase followed by an execution phase, and that the JavaScript engine actually runs through our code multiple times."]


      ]
    },
    {
      "title": "IIFEs and Modules",
      "content": [
        ["p", "IIFE stands for an immediately invoked function expression. It has a few benefits:"],
        ["ol", ["Creates a new scope for variables, which prevents poling the global scope.", "Is great for creating modules as it can contain both public and private methods", "Leads to cleaner code because it is executed immediately and does not have to be both defined and then later called."]],
        ["p", "The syntax for an iife is below:"],
        ["img", "/public/blog/iife/iife1.JPG"],
        ["p", "The extra parentheses at the end are what immidately invoke (hence the name) the function, without being explicitly called later. Those parentheses can be placed either directly after or before the closing parentheses that wraps the function. An iife can also take an argument:"],
        ["img", "/public/blog/iife/iife2.JPG"],
        ["p", "An iife is a great way to create a module in JavaScript since it can contain both public and private methods. It can also be saved to a variable. These features are all shown below:"],
        ["img", "/public/blog/iife/iife3.JPG"],
        ["p", "There are a number of cool things going on here. First, the backticks ( ` ) are a new ES6 feature that allow for string interpolation in JavaScript. But back to the IIFE, by saving it to the variable myModule it is no longer being invoked at runtime, but rather is accessible to us later in the program. When we call the sayEverything method on line 23, sayEverything is able to access both the sayAge and sayFood methods, which are both private and inaccessible directly from the global scope. On line 24 the takeArg method shows that we can pass in a parameter to one of these public methods. Line 25 shows that none of the function defined outside of the return are private, and not available from the global scope. To make a method public, simply define it inside of the return, and separate multiple functions with commas. These public methods have access to all private functions and variables defined inside of the IIFE."]

      ]
    }

  ]
}